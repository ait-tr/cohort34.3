1. Previously, we checked the correct operation of the methods we created by running several times
   application, with different sets of initial data, and comparing the result obtained in the console
   with expected. It is very uncomfortable. For example, any code change requires repeating the entire
   the above procedure again. There are special libraries that make it easier
   and automate this process. One of the most popular for Java is JUnit.

2. Working with JUnit is to create a class with tests and configure it.
   In the class, we can specify objects for testing and the necessary data as fields.
   In the @BeforeEach annotated method, we give initial settings to the object under test.
   And in the methods marked with the @Test annotation, we write code that checks the object under test.
   Checks are carried out using methods beginning with the word assert... (which exist
   a large number for all cases), and accepting for comparison the result obtained and the expected one.
   All specified methods and annotations are provided by the JUnit library.
   Each method marked with the @Test annotation is, in fact, a separate "main".

Useful article:
https://www.baeldung.com/java-unit-testing-best-practices

------------------------------

# Unit - тестирование

1. Ранее мы проверяли правильность работы созданных нами методов, запуская несколько раз
   аппликацию с классом main, с различными наборами исходных данных, и сравнивая результат полученный в консоли
   с ожидаемым. Это очень неудобно. Например, любое изменение кода, требует повторения всей
   вышеописанной процедуры заново. Существуют специальные библиотеки, которые позволяют облегчить
   и автоматизировать этот процесс. Одна из самых популярных для Java, это JUnit.

2. Работа с JUnit заключается в создании класса с тестами и настройке его.
   В классе в качестве полей мы можем указать объекты для тестирования и необходимые данные.
   В методе помеченном аннотацией @BeforeEach мы даем начальные настройки тестируемому объекту.
   А в методах помеченных аннотацией @Test мы пишем код проверяющий тестируемый объект.
   Проверки осуществляются при помощи методов начинающихся со слова **assert**... (которых существует
   большое колличество на все случаи), и принимающих для сравнения полученный результат и ожидаемый.
   Все указанные методы и аннотации предоставляются библиотекой JUnit.
   Каждый метод помеченный аннотацией @Test, по сути является отдельным "мейном".

Полезная статья:
https://www.baeldung.com/java-unit-testing-best-practices

_________________________________

## Юнит-тестирование (подробно)

**Модульное тестирование**, или **юнит-тестирование** (*англ.* **unit testing**) — процесс в
программировании, позволяющий проверить на корректность отдельные модули (методы) исходного кода
программы.

### Зачем и когда пишутся тесты
Тесты пишутся программистами для каждого метода класса, который сложнее, чем sout или вызов
стандартных имеющихся в Java методов. Обычно, тесты пишет сам программист или другой
прграммист-коллега (junior) **параллельно** по ходу разработки или в ходе рефакторинга кода
(это обычный/регулярный процесс).

Модульное тестирование позволяет достаточно быстро проверить, не привело ли очередное изменение кода
(**рефакторинг**) к его **регрессии**, то есть к появлению ошибок в уже оттестированных местах программы.
Тестирование облегчает обнаружение и устранение таких ошибок, НО не обеспечивает полной гарантии.

**ВНИМАНИЕ!!!**
Можно добиться 100% покрытия кода тестами, но не 100% уверенности, что тесты проверяют ВСЕ СЛУЧАИ и
ВСЕ НАБОРЫ ДАННЫХ - **это остается на совести разработчиков**.

#### Не нужно писать тесты, если
Вы обладаете идеальной памятью и даром предвидения, ваш код способен изменять себя сам,
вслед за требованиями клиента, а иногда он объясняет клиенту, что его требования не нужно реализовывать.

**Любой долгосрочный проект без надлежащего покрытия тестами обречен рано или поздно
быть переписанным с нуля.**

**Тесты должны:**
- Быть достоверными, то есть проверять верные случаи и утверждения;
- Не зависеть от окружения, на котором они выполняются;
- Легко поддерживаться, то есть легко читаться и быть простыми для понимания,
  даже новый разработчик должен понять, **что именно** тестируется;
- Соблюдать единую конвенцию именования;
- Запускаться регулярно в автоматическом режиме.

**Алгоритм проведения Unit тестов**
1. Выбрать/создать директорию для проведения Unit-тестирования (обычно - в директории где
   находится тестируемый класс и его методы)
2. Создать в этой директории новый класс (java-файл) с наименованием ИмяКлассаTest
3. Выполнить в этот Класс (файл) импорт библиотек:
   import org.junit.jupiter.api.Assertions;
   import org.junit.jupiter.api.BeforeEach;
   import org.junit.jupiter.api.Test;
4. Подключаем тестируемый класс и его методы строкой вида:
   ИмяКласса имяКласса; // это новое поле в классе ИмяКлассаTest, в котором подключается объект тестируемого класса.
5. Директива @BeforeEach
   void setUp(){
   Имя класса = new имяKласса(); // создаем экземпляр объекта тестируемого класса перед каждым тестом
   }
6. Директивы
   @Test
   @DisplayName("В этом тексте можно описать то, что мы тестируем")

   создаь метод, вызывающий assertEquals (нужное значение, вызов тестируемого метода , "Сообщение(пояснение) о ...")

   Пример:   
   void testMultiPly(){
   assertEquals(20,calculator.multiply(4,5),"4*5 should be 20");
   }
7. Запустить тест

## Придерживайтесь единого стиля написания тела теста
Отлично зарекомендовал себя подход **AAA**
(arrange, act, assert - упорядочить, выполнить действие, сравнить результат).

Пример того, как это выглядит на примере с калькулятором:

`import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;

public class CalculatorTests {

@Test
public void sum_2Plus5_7Returned() {
// arrange
Calculator calc = new Calculator(); // создали свой экземпляр калькулятора

		// act
		int res = calc.sum(2, 5); // вызвали метод из тестируемого класса

		// assert
		assertEquals(7, res); // выполнили сравнение желаемого с полученным
	}
}`

## Тестируйте один метод за один раз
Каждый тест должен охватывать одну понятную область и/или возможность.
Если процесс слишком сложен (например, покупка в интернет магазине),
разделите его на несколько частей и протестируйте их отдельно.
Если вы не будете придерживаться этого правила, ваши тесты станут нечитаемыми
и вскоре вам окажется очень сложно их поддерживать.


# Фреймворк JUnit

**JUnit** - один из самых популярных фреймворков, используемых для тестирования кода в **Java**.

[Официальный сайт](https://junit.org/junit5/)

[Руководство пользователя](https://junit.org/junit5/docs/current/user-guide/)

[Репозиторий](https://github.com/junit-team/junit5/) на **GitHub**

[Текстовая инструкция по настройке IntelliJ Idea (на английском)](https://www.jetbrains.com/help/idea/junit.html)

[Видеоинструкция по настройке IntelliJ Idea (на английском)](https://www.youtube.com/watch?v=we3zJE3hlWE)
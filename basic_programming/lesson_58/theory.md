


_______________________________________________________________

# Класс `Collections`

Класс `Collections`, как и класс `Math`, в основном содержит **статические** методы и предназначен для работы
с коллекциями - списками и множествами.

Все методы класса описаны в [документации]
(https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/Collections.html#method-summary).

Примечание: для работы с массивами есть похожий класс [`Arrays`]
(https://docs.oracle.com/en/java/javase/20/docs/api/java.base/java/util/Arrays.html).

Нас интересуют в первую очередь методы:
- `max(Collection<?> coll)`
- `min(Collection<?> coll)`
- `reverse(List<?> list)`
- `sort(List<T> list)`

Методы `min()` и `max()` работают с любыми коллекциями (см. интерфейс `Collection` ниже) и возвращают
минимальный и максимальный элементы.

Методы `reverse()` и `sort()` работают с любыми списками (интерфейс `List`) и переворачивают или
сортируют список. Изменения происходят "на месте" (*in-place*) - меняется существующий список
(переданный в аргументах), а не создаётся новый.

# Лямбда-выражение

Функциональное программирование — парадигма программирования, в которой процесс вычисления трактуется
как вычисление значений функций в **математическом** понимании последних (в отличие от функций как подпрограмм
в процедурном программировании).

Если при использовании функционального интерфейса, лямбда выражение состоит из вызова одного метода,
то можно использовать синтаксис method reference.

Синтаксис method reference:
- для статических методов классов: Class::method 
- для методов объектов: object::method
- для конструкторов: Class::new

# Streams
Functional Streams можно создать для любого итерируемого объекта. Стрим это последовательность операций
над элементами итерируемого объекта.

Стримы состоят из промежуточных и терминальных операций. Промежуточных операций может быть несколько и они
всегда возвращают стрим. Терминальная операция может быть только одна, и она помещается в конец стрима. Терминальная
операция возвращает результат работы всего стрима.

Стрим "ленивый". Т. е. стрим начнет работать, только когда к нему будет добавлена терминальная операция.

Если в стриме, "на конвеере", оказываются объекты, которые в свою очередь являются итерируемыми,
то при помощи промежуточного метода flatMap можно "вытрусить" содержимое этих объектов. В таком случае
далее "по конвееру" будет двигаться уже содержимое объектов.

Терминальный метод collect может собрать содержимое стрима в нужную нам структуру. Для этого ему надо
передать объект имплементирующий интерфейс Collector. На практике имплементировать самим интерфейс Collector
приходится редко, т. к. в классе Collectors есть много методов возвращающих разнообразные коллекторы. Например,
при помощи Collectors.toList(), можно получить коллектор собирающий элементы стрима в лист, а при помощи
Collectors.toSet() - в сет.

Collectors.groupingBy позволяет сгруппировать элементы стрима в мапу, по ключу, который определяется
соответствующей функцией. При этом элементы соответствующие одному ключу собираются по умолчанию в лист.

У Collectors.groupingBy есть перегруженные варианты. Например, вместо дефолтного листа, в качестве вэлью
можно использовать результат работы какого-нибудь коллектора.

Подробно о схеме работы стрима и основных операциях, смотрите в презентации.

[Functional Programming in Java](https://github.com/ait-tr/cohort34.3/blob/main/basic_programming/lesson_58/FP.pdf)
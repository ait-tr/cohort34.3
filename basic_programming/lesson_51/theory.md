# What we have learned over the past two weeks


_______________________________________________________________

# JVF: Set, HashSet 

Из интерфейсов расширяющих интерфейс Collection, мы рассмотрели интерфейс List, на котором реализованы 
ArrayList и LinkedList. 

Set в переводе с английского - это "множество", множество каких-то объектов в контексте Java.
Особенность этого множества в том, что оно может хранить **только уникальные значения**, 
элементы этого множества.

Set - это **интерфейс** с методами для работы со множеством:
- добавить во множество,
- удалить из множества,
- проверить наличие элемента во множестве.
 
Интерфейс Set расширяет интерфейс Collection, и определяет коллекции, которые 
**не содержат двух одинаковых элементов**.

Интерфейс Set наследуется в классе HashSet, который позволяет создать набор/коллекцию уникальных элементов.

Если мы говорим об уникальности элементов в коллекции, то мы должны решить, как эта уникальность определяется. 
Есть всего две опции:
- 1) два объекта одинаковые, если метод equals возвращает true. 
- 2) два объекта одинаковые, если метод сравнения (compareTo или compare) возвращает ноль.

На опции один, построена реализация интерфейса Set называемая HashSet. Именно поэтому equals() и hashSet 
реализуются "парой", совместно.

На опции два, построена реализация интерфейса Set называемая TreeSet.

Примеры полезных и нужных HashSet:
- списки e-mail
- номера телефонов
- аккаунты в банковских системах
- идентификационные номера
- налоговые номера
- ...

Итак, что такое HashSet? 
Ответ: это класс, который реализует(implements) интерфейсы Set, Collection, Iterable.  
Индексов в этой структуре нет, элемент ищется по его хешу. Хеш каждый раз вычисляется.
Хеши все уникальные, так как элементы уникальные!

**ВНИМАНИЕ!**
Индексов у элементов сета нет! Элемент множества ищется по совпадению его хеша с хешем искомого элемента.
Хеш быстро вычисляется и хранится в памяти компьютера в специальных хеш-таблицах.

**Примеры:**
Бренды автомобилей - это множество, где каждый элемент должен быть уникален.
Их сейчас порядка 100.

Давайте приведем примеры полезных Set из жизни:
- буквенный алфавит
- словарь языка
- индексы для почтовых адресов
- VIN автомобилей
- серийный номер изделия
- штирх-код
- ссылки в Интернете
- из финансовой сферы: счет клиента, SWIFT-код, ...
- номера купюр
- Tax ID
- e-mail в пределах регистратора
- IP - адрес

Вопрос: Как ведет себя Set при попытке добавить в него имеющийся уже в нем элемент?
Ответ: игнорирует эту операцию.

**_Синтаксис для инициализации HashSet:_**
      `Set<Type> myHashSet = new HashSet<>();`

### Как вычисляется Hash ???
Метод hashCode() – возвращает хэш-код для данной строки (набор символов).
Хэш-значение пустой строки равно нулю.
hashCode(строка) = s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1], ^ - это возведение в степень
s[0] - это 1-й элемент строки (символ), s[1] - 2-й элемент и т.д.
Простое число 31 подобрано опытным путем.

### Для чего нужен Hash?
Hash - это ключ (уникальный идентификатор) для hash-таблицы, в которой хранятся
пары значений:
hash 1-го элемента | 1-й элемент множества
hash 2-го элемента | 2-й элемент множества
...

### HashSet (summary)
1. Принципиальная невозможность повторений элементов множества (коллекции);
2. Нет порядка, при добавлении имеющегося элемент попадает куда-то внутрь множества;
3. Нет индексов элементов, у каждого элемента есть Hash, по которому он и определяется (находится);
4. Методы HashSet:
- Добавить элемент(ы): `add()`, `addAll()`
- Удалить элемент(ы): `remove()`, `removeAll()`
- Очистить множество (удалить все элементы): `clear()`
- Проверить, есть ли элемент(ы): `contains()`, `containsAll()`
- Узнать размер: `size()`

В множестве **не бывает индексов**, и его нельзя **"отсортировать"**!





